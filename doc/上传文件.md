# 上传文件
在OSS中，用户操作的基本数据单元是文件（Object）。
单个文件最大允许大小根据上传数据方式不同而不同，Put Object方式最大不能超过5GB, 使用multipart上传方式文件大小不能超过48TB。

## 简单上传

### 从数据流(io.Reader)中读取数据上传

通过Bucket.PutObject完成简单上传。

> 提示：
> 
> - 简单上传的示例代码在`sample/put_object.go`。

#### 字符串(string)上传
```go
    import "strings"
    import "github.com/aliyun/aliyun-oss-go-sdk/oss"
  
    client, err := oss.New("Endpoint", "AccessKeyId", "AccessKeySecret")
    if err != nil {
        // HandleError(err)
    }

    bucket, err := client.Bucket("my-bucket")
    if err != nil {
        // HandleError(err)
    }
    
    err = bucket.PutObject("my-object", strings.NewReader("MyObjectValue"))
    if err != nil {
        // HandleError(err)
    }
```

#### byte数组上传
```go
    import "bytes"
    import "github.com/aliyun/aliyun-oss-go-sdk/oss"
   
    client, err := oss.New("Endpoint", "AccessKeyId", "AccessKeySecret")
    if err != nil {
        // HandleError(err)
    }

    bucket, err := client.Bucket("my-bucket")
    if err != nil {
        // HandleError(err)
    }
    
    err = bucket.PutObject("my-object", bytes.NewReader([]byte("MyObjectValue")))
    if err != nil {
        // HandleError(err)
    }
```

#### 本地文件上传
```go
    import "os"
    import "github.com/aliyun/aliyun-oss-go-sdk/oss"
   
    client, err := oss.New("Endpoint", "AccessKeyId", "AccessKeySecret")
    if err != nil {
        // HandleError(err)
    }

    bucket, err := client.Bucket("my-bucket")
    if err != nil {
        // HandleError(err)
    }
    
    fd, err := os.Open("LocalFile")
    if err != nil {
        // HandleError(err)
    }
    defer fd.Close()
    
    err = bucket.PutObject("my-object", fd)
    if err != nil {
        // HandleError(err)
    }
```

### 根据本地文件名上传

通过Bucket.PutObjectFromFile可以上传指定的本地文件，把本地文件内容作为Object的值。

```go
    import "github.com/aliyun/aliyun-oss-go-sdk/oss"
    
    client, err := oss.New("Endpoint", "AccessKeyId", "AccessKeySecret")
    if err != nil {
        // HandleError(err)
    }
    
    bucket, err := client.Bucket("my-bucket")
    if err != nil {
        // HandleError(err)
    }
    
    err = bucket.PutObjectFromFile("my-object", "LocalFile")
    if err != nil {
        // HandleError(err)
    }
```

> 注意：
> 
> - 使用上述方法上传最大文件不能超过5G。如果超过请使用分片上传。


#### 上传时指定元信息

使用数据流上传文件时，用户可以指定一个或多个文件(Object)的元信息。元数据的名称大小写不敏感，比如用户上传文件时，定义名字为“name”的meta，使用Bucket.GetObjectDetailedMeta读取结果是：“X-Oss-Meta-Name”，比较/读取时请忽略大小写。

可以指定的元信息如下：

| 参数 | 说明 |
| :--- | :--- |
| CacheControl | 指定该Object被下载时的网页的缓存行为。|
| ContentDisposition | 指定该Object被下载时的名称。|
| ContentEncoding | 指定该Object被下载时的内容编码格式。|
| Expires | 指定过期时间。用户自定义格式，建议使用http.TimeFormat格式。|
| ServerSideEncryption | 指定oss创建object时的服务器端加密编码算法。合法值：AES256。|
| ObjectACL | 指定oss创建object时的访问权限。|
| Meta | 自定义参数，以"X-Oss-Meta-"为前缀的参数。|

```go
    import (
        "strings"
        "time"
        "github.com/aliyun/aliyun-oss-go-sdk/oss"
    )
    
	client, err := oss.New("Endpoint", "AccessKeyId", "AccessKeySecret")
	if err != nil {
		// HandleError(err)
	}

	bucket, err := client.Bucket("my-bucket")
	if err != nil {
		// HandleError(err)
	}

	expires := time.Date(2049, time.January, 10, 23, 0, 0, 0, time.UTC)
	options := []oss.Option{
		oss.Expires(expires),
		oss.ObjectACL(oss.ACLPublicRead),
		oss.Meta("MyProp", "MyPropVal"),
	}
	err = bucket.PutObject("my-object", strings.NewReader("MyObjectValue"), options...)
	if err != nil {
		// HandleError(err)
	}
```

> 提示：
> - Bucket.PutObject、Bucket.PutObjectFromFile都支持上传时指定元数据。


## 创建模拟文件夹

OSS服务是没有文件夹这个概念的，所有元素都是以文件来存储。但给用户提供了创建模拟文件夹的方式，如下代码：
```go
    import "strings"
    import "github.com/aliyun/aliyun-oss-go-sdk/oss"
   
    client, err := oss.New("Endpoint", "AccessKeyId", "AccessKeySecret")
    if err != nil {
        // HandleError(err)
    }

    bucket, err := client.Bucket("my-bucket")
    if err != nil {
        // HandleError(err)
    }
    
    err = bucket.PutObject("my-dir/", strings.NewReader(""))
    if err != nil {
        // HandleError(err)
    }
```

> 提示：
> 
> - 创建模拟文件夹本质上来说是创建了一个空文件。
> - 对于这个文件照样可以上传下载,只是控制台会对以"/"结尾的文件以文件夹的方式展示。
> - 所以用户可以使用上述方式来实现创建模拟文件夹。
> - 而对文件夹的访问可以参看[文件夹功能模拟]({{doc/[5]SDK/Go-SDK/管理文件.md}})
>

## 追加上传
OSS支持可追加的文件类型，通过`Bucket.AppendObject`来上传可追加的文件，
调用时需要指定文件追加的位置，对于新创建文件，这个位置是0；对于已经存
在的文件，这个位置必须是追加前文件的长度。

- 文件不存在时，调用`AppendObject`会创建一个可追加的文件；
- 文件存在时，调用`AppendObject`会向文件末尾追加内容。

> 提示：
> - 追加上传的示例代码在`sample/append_object.go`。

```go
    import "strings"
    import "github.com/aliyun/aliyun-oss-go-sdk/oss"
    
    client, err := oss.New("Endpoint", "AccessKeyId", "AccessKeySecret")
    if err != nil {
        // HandleError(err)
    }

    bucket, err := client.Bucket("my-bucket")
    if err != nil {
        // HandleError(err)
    }
    
    var nextPos int64 = 0
    // 第一次追加的位置是0，返回值为下一次追加的位置
    nextPos, err = bucket.AppendObject("my-object", strings.NewReader("YourObjectValue"), nextPos)
    if err != nil {
        // HandleError(err)
    }
    
    // 第二次追加
    nextPos, err = bucket.AppendObject("my-object", strings.NewReader("YourObjectValue"), nextPos)
    if err != nil {
        // HandleError(err)
    }
    
    // 您还可以进行多次Append
```

> 注意：
> 
> - 只能向可追加的文件（即通过`AppendObject`创建的文件）追加内容
> - 可追加的文件不能被拷贝
> 

第一次追加时，即位置开始位置是0的追加，您可以指定文件(Object)的元信息；除了第一次追加，其它追加不能指定元信息。
```go
    // 第一次追加指定元信息
    nextPos, err = bucket.AppendObject("my-object", strings.NewReader("YourObjectValue"), 0, oss.Meta("MyProp", "MyPropVal"))
    if err != nil {
        // HandleError(err)
    }
```

## 分片上传
除了通过PutObject接口上传文件到OSS以外，OSS还提供了另外一种上传模式 —— Multipart Upload。
用户可以在如下的应用场景内（但不仅限于此），使用Multipart Upload上传模式，如：

- 需要支持断点上传。
- 上传超过100MB大小的文件。
- 网络条件较差，和OSS的服务器之间的链接经常断开。
- 上传文件之前，无法确定上传文件的大小。

### 封装后的分片上传
其实现原理是将要上传的文件分成若干个分片上传，最后所有分片都上传成功后，完成整个文件的上传。
所以用户需要指定分片的大小，单位是Bytes。分片的最小值是100KB，最大值是5GB，请根据网络情况选择合适的分片大小。
```go
    import "github.com/aliyun/aliyun-oss-go-sdk/oss"
    
    client, err := oss.New("Endpoint", "AccessKeyId", "AccessKeySecret")
    if err != nil {
        // HandleError(err)
    }

    bucket, err := client.Bucket("my-bucket")
    if err != nil {
        // HandleError(err)
    }
    
    // 分片大小是1MB
    err = bucket.UploadFile("my-object", "LocalFile", 1024 * 1024)
    if err != nil {
        // HandleError(err)
    }
```

> 提示：
> 
> - 分片上传Bucket.UploadFile时，您可以指定文件(Object)的元信息。
>
```go
    imur, err := bucket.UploadFile("my-object", "LocalFile", 1024 * 1024, oss.Meta("MyProp", "MyPropVal"))
    if err != nil {
            // HandleError(err)
    }
```
>

### 分步完成MultipartUpload

分片上传(MultipartUpload)一般的流程如下:

1. 初始化一个分片上传任务（InitiateMultipartUpload）
2. 逐个或并行上传分片（UploadPart）
3. 完成上传（CompleteMultipartUpload）

> 提示：
> 
> - 分片上传的示例代码在`samples/multipart_upload.go`

#### 按照片数/片大小分片上传
本地有一个大文件bigfile.zip，将其分成10片上传到OSS中。
```go
    import "github.com/aliyun/aliyun-oss-go-sdk/oss"
    
    client, err := oss.New("Endpoint", "AccessKeyId", "AccessKeySecret")
    if err != nil {
        // HandleError(err)
    }

    bucket, err := client.Bucket("my-bucket")
    if err != nil {
        // HandleError(err)
    }
    
    // 按照指定片数分割大文件
    chunks, err := oss.SplitFileByPartNum("bigfile.zip", 10)
    if err != nil {
        // HandleError(err)
    }

    // 初始化分片上传任务
    imur, err := bucket.InitiateMultipartUpload("my-object")
    if err != nil {
        // HandleError(err)
    }
    
    // 上传分片
    parts := []oss.UploadPart{}
    for _, chunk := range chunks {
        part, err := bucket.UploadPartFromFile(imur, "bigfile.zip", chunk.Offset,
            chunk.Size, chunk.Number)
        if err != nil {
            // HandleError(err)
        }
        parts = append(parts, part)
    }

    // 完成上传
    _, err = bucket.CompleteMultipartUpload(imur, parts)
    if err != nil {
        // HandleError(err)
    }
```

> 注意：
> 
> - 上面程序的核心是调用UploadPart方法来上传每一个分片，但是要注意以下几点：
> - UploadPart 方法要求除最后一个Part以外，其他的Part大小都要大于100KB。但是Upload Part接口并不会立即校验上传
Part的大小（因为不知道是否为最后一片）；只有当Complete Multipart Upload的时候才会校验。
> - OSS会将服务器端收到Part数据的MD5值放在ETag头内返回给用户。
> - 为了保证数据在网络传输过程中不出现错误，SDK会自动设置Content-MD5，OSS会计算上传数据的MD5值与SDK计算的MD5值比较，
如果不一致返回InvalidDigest错误码。
> - Part号码的范围是1~10000。如果超出这个范围，OSS将返回InvalidArgument的错误码。
> - 每次上传part时都要把流定位到此次上传片开头所对应的位置。
> - 每次上传part之后，OSS的返回结果会包含一个 PartETag 对象，他是上传片的ETag与片编号（PartNumber）的组合，
> - 在后续完成分片上传的步骤中会用到它，因此我们需要将其保存起来。一般来讲我们将这些 PartETag 对象保存到List中。
    
    
> 提示：
> 
> - 您还可以调用oss.SplitFileByPartSize把文件按照大小切分，然后分片删除。如bigfile.zip按照1M分片：
>
```go
    chunks, err := oss.SplitFileByPartSize("bigfile.zip", 1024*1024)
    if err != nil {
        // HandleError(err)
    }
```
>
> - 初始化上传任务时候，您可以指定文件(Object)的元信息。
>
```go
    imur, err := bucket.InitiateMultipartUpload("my-object", oss.Meta("MyProp", "MyPropVal"))
    if err != nil {
        // HandleError(err)
    }
```
>
> - 初始化上传任务后，或者上传一部分分片后，由于某种原因需要取消任务，您可以使用AbortMultipartUpload取消分片上传任务，其中参数imur是InitiateMultipartUpload的返回值。
>
```go
    err = bucket.AbortMultipartUpload(imur)
    if err != nil {
        // HandleError(err)
    }
```
>

#### 分片分组上传
上面的分片上传需要先知道文件的大小，但是某种情况下文件大小是不可预知，这种情况可以通过指定文件的偏移量和片大小分别上传分片。
```go
    import "os"
    import "github.com/aliyun/aliyun-oss-go-sdk/oss"
    
    client, err := oss.New("Endpoint", "AccessKeyId", "AccessKeySecret")
    if err != nil {
        // HandleError(err)
    }

    bucket, err := client.Bucket("my-bucket")
    if err != nil {
        // HandleError(err)
    }
    
    // 上传文件的前3个分片，分片大小是1MB
    chunks := []oss.FileChunk {
        {Number: 1, Offset: 0 * 1024 * 1024 , Size: 1024 * 1024},
        {Number: 2, Offset: 1 * 1024 * 1024 , Size: 1024 * 1024},
        {Number: 3, Offset: 2 * 1024 * 1024 , Size: 1024 * 1024},
    }
    
    fd, err := os.Open("bigfile.zip")
    if err != nil {
        // HandleError(err)
    }
    defer fd.Close()
    
    // 初始化分片上传任务
    imur, err := bucket.InitiateMultipartUpload("my-object")
    if err != nil {
        // HandleError(err)
    }
    
    // 上传前3个分片
    parts := []oss.UploadPart{}
    for _, chunk := range chunks {
        fd.Seek(chunk.Offset, os.SEEK_SET)
        part, err := bucket.UploadPart(imur, fd, chunk.Size, chunk.Number)
        if err != nil {
            // HandleError(err)
        }
        parts = append(parts, part)
    }
    
    // 后面的分片在文件增长后再上传
    // ... ...
    
    // 所有分片上传完毕后，完成上传
    _, err = bucket.CompleteMultipartUpload(imur, parts)
    if err != nil {
        // HandleError(err)
    }
```   

#### 并发上传分片
分片上传时，多个分片可以并发上传，或者由不同进程甚至不同机器完成。
```go
    import (
        "sync"
        "github.com/aliyun/aliyun-oss-go-sdk/oss"
    )
    
	client, err := oss.New("Endpoint", "AccessKeyId", "AccessKeySecret")
    if err != nil {
        // HandleError(err)
    }

    bucket, err := client.Bucket("my-bucket")
    if err != nil {
        // HandleError(err)
    }
    
    // 把文件分成10片
    partNum := 10
	chunks, err := oss.SplitFileByPartNum("LocalFile", partNum)
	if err != nil {
		// HandleError(err)
	}

    // 初始化上传任务
	imur, err := bucket.InitiateMultipartUpload("my-object")
	if err != nil {
		// HandleError(err)
	}

	// 并发上传分片
	var waitgroup sync.WaitGroup
	var parts = make([]oss.UploadPart, partNum)
	for _, chunk := range chunks {
		waitgroup.Add(1)
		go func(chunk oss.FileChunk) {
			part, err := bucket.UploadPartFromFile(imur, "LocalFile", chunk.Offset,
				chunk.Size, chunk.Number)
			if err != nil {
				// HandleError(err)
			}
			parts[chunk.Number - 1] = part
			waitgroup.Done()
		}(chunk)
	}
	
	// 等待分片上传完成
	waitgroup.Wait()

	// 提交上传任务
	_, err = bucket.CompleteMultipartUpload(imur, parts)
	if err != nil {
		// HandleError(err)
	}
```


### 获取所有已上传的片信息
您可以用Bucket.ListUploadedParts获取某个上传事件所有已上传的分片。
```go 
    import "fmt"
    import "github.com/aliyun/aliyun-oss-go-sdk/oss"
    
    client, err := oss.New("Endpoint", "AccessKeyId", "AccessKeySecret")
    if err != nil {
        // HandleError(err)
    }

    bucket, err := client.Bucket("my-bucket")
    if err != nil {
        // HandleError(err)
    }
    
    imur, err := bucket.InitiateMultipartUpload("my-object")
    if err != nil {
        // HandleError(err)
    }
    
    lsRes, err := bucket.ListUploadedParts(imur)
    if err != nil {
        // HandleError(err)
    }
    fmt.Println("Parts:", lsRes.UploadedParts)
```


### 获取所有分片上传的任务
通过`Bucket.ListMultipartUploads`来列出当前分片上传任务。主要的参数如下：

| 参数 | 说明 |
| :--- | :--- |
| Delimiter | 用于对Object名字进行分组的字符。所有名字包含指定的前缀且第一次出现delimiter字符之间的object作为一组元素。 
| MaxUploads | 限定此次返回Multipart Uploads事件的最大数目，默认为1000，max-uploads取值不能大于1000。
| KeyMarker | 所有Object名字的字典序大于KeyMarker参数值的Multipart事件。 
| Prefix  | 限定返回的文件名(object)必须以Prefix作为前缀。注意使用Prefix查询时，返回的文件名(Object)中仍会包含Prefix。   

#### 使用默认参数
```go 
    import "fmt"
    import "github.com/aliyun/aliyun-oss-go-sdk/oss"
    
    client, err := oss.New("Endpoint", "AccessKeyId", "AccessKeySecret")
    if err != nil {
        // HandleError(err)
    }

    bucket, err := client.Bucket("my-bucket")
    if err != nil {
        // HandleError(err)
    }
    
    lsRes, err := bucket.ListMultipartUploads()
    if err != nil {
        // HandleError(err)
    }
    fmt.Println("Uploads:", lsRes.Uploads)
```

#### 指定前缀
```go     
    lsRes, err := bucket.ListMultipartUploads(oss.Prefix("my-object-"))
    if err != nil {
        // HandleError(err)
    }
    fmt.Println("Uploads:", lsRes.Uploads)
```

#### 指定最多返回100条结果数据
```go     
    lsRes, err := bucket.ListMultipartUploads(oss.MaxUploads(100))
    if err != nil {
        // HandleError(err)
    }
    fmt.Println("Uploads:", lsRes.Uploads)
```

#### 同时指定前缀和最大返回条数
```go     
    lsRes, err := bucket.ListMultipartUploads(oss.Prefix("my-object-"), oss.MaxUploads(100))
    if err != nil {
        // HandleError(err)
    }
    fmt.Println("Uploads:", lsRes.Uploads)
```
